rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isValidString(field) {
      return request.resource.data[field] is string 
        && request.resource.data[field].size() > 0;
    }
    
    function isValidTimestamp(field) {
      return request.resource.data[field] is timestamp;
    }

    // Hardcoded admin UID list
    function isAdmin() {
      return isAuthenticated() && 
        (request.auth.uid == "08y0oUgfD2aWOgScPJRDdyfehsv2" || 
         request.auth.uid == "Ela2Ijh7kedHFLFMNGuKSaygWE02");
    }
    
    // Rivers collection - open for authenticated users
    match /rivers/{riverId} {
      allow read: if isAuthenticated();
      // Only hardcoded admin users can create/update/delete rivers
      allow create, update, delete: if isAdmin();
      
      // River runs subcollection - open for authenticated users
      match /river_runs/{runId} {
        allow read: if isAuthenticated();
        // Only hardcoded admin users can create/update/delete river runs
        allow create, update, delete: if isAdmin();
      }
    }
    
    // River runs collection - open for authenticated users (legacy top-level)
    match /river_runs/{runId} {
      allow read: if isAuthenticated();
      // Only hardcoded admin users can create/update/delete river runs
      allow create, update, delete: if isAdmin();
    }
    
    // Gauge stations collection - publicly readable
    match /gauge_stations/{stationId} {
      allow read: if true;
      
      // Only backend should write station data
      allow create, update, delete: if false;
    }
    
    // Water stations collection - publicly readable
    match /water_stations/{stationId} {
      allow read: if true;
      
      // Only backend should write station data
      allow create, update, delete: if false;
    }
    
    // Station levels collection - real-time flow data (publicly readable)
    match /station_levels/{stationId} {
      allow read: if isAuthenticated();
      
      // Only backend should write station data
      allow create, update, delete: if false;
    }
    
    // Station current collection - current flow data (publicly readable)
    match /station_current/{stationId} {
      allow read: if isAuthenticated();
      
      // Only backend should write station data
      allow create, update, delete: if false;
    }
    
    // Stations collection - historical flow data (publicly readable)
    match /stations/{stationId} {
      allow read: if isAuthenticated();
      
      // Only backend should write station data
      allow create, update, delete: if false;
      
      // Daily means subcollection
      match /daily_means/{dateId} {
        allow read: if isAuthenticated();
        allow create, update, delete: if false;
      }
      
      // Readings subcollection (yearly documents)
      match /readings/{yearId} {
        allow read: if isAuthenticated();
        allow create, update, delete: if false;
      }
    }
    
    // User favorites collection - strict user ownership
    match /user_favorites/{userId} {
      allow read: if isOwner(userId);
      
      allow create: if isOwner(userId)
        && request.resource.data.keys().hasAll(['rivers', 'lastUpdated'])
        && request.resource.data.rivers is list;
      
      allow update: if isOwner(userId)
        && request.resource.data.rivers is list;
      
      allow delete: if isOwner(userId);
      
      // Subcollection for river details
      match /river_details/{detailId} {
        allow read: if isOwner(userId);
        
        allow create: if isOwner(userId)
          && isValidString('stationId')
          && isValidTimestamp('addedAt');
        
        allow update: if isOwner(userId);
        
        allow delete: if isOwner(userId);
      }
    }
    
    // River descents (logbook entries) - PRIVATE user-owned data
    match /river_descents/{descentId} {
      // Users can read their own descents, admins can query/read all descents
      allow read: if isAdmin() || 
        (isAuthenticated() && request.auth.uid == resource.data.userId);
      
      allow create: if isAuthenticated()
        && isValidString('riverRunId')
        && isValidString('userId')
        && request.resource.data.userId == request.auth.uid
        && isValidTimestamp('timestamp');
      
      allow update: if isAuthenticated()
        && request.auth.uid == resource.data.userId
        && request.resource.data.userId == resource.data.userId; // Prevent changing ownership
      
      allow delete: if isAuthenticated()
        && request.auth.uid == resource.data.userId;
    }
    
    // Users collection - for premium status and user profiles
    match /users/{userId} {
      // Users can read their own data
      allow read: if isOwner(userId);
      
      // Users can create their own profile
      allow create: if isOwner(userId)
        && request.resource.data.keys().hasAll(['email'])
        && (!request.resource.data.keys().hasAny(['isPremium', 'subscriptionStatus', 'subscriptionId', 'stripeCustomerId'])
            || request.resource.data.isPremium == false); // Prevent setting premium on creation
      
      // Users can update their own data, but NOT premium status fields
      // Premium status can only be set by Cloud Functions (admin)
      allow update: if isOwner(userId)
        && (!request.resource.data.diff(resource.data).affectedKeys().hasAny([
          'isPremium', 
          'subscriptionStatus', 
          'subscriptionId', 
          'subscriptionType',
          'stripeCustomerId'
        ]));
      
      // Prevent deletion of user documents
      allow delete: if false;
    }
    
    // App configuration collection - for version checking, feature flags, etc.
    match /app_config/{docId} {
      // Version document should be readable by all authenticated users
      // This enables PWA-compatible version checking via Firestore
      allow read: if isAuthenticated() && docId == 'version';
      
      // Only admins can write app configuration
      allow create, update, delete: if isAdmin();
    }
    
    // Catch-all rule - deny access to any other collections
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
